import { NextResponse } from "next/server"
import { NextRequest } from "next/server"
import { connectDB } from "@/lib/mongodb"
import { Collections } from "@/lib/db-config"
import { ObjectId } from "mongodb"
import bcrypt from "bcryptjs"
import { withAuth } from "@/lib/api-auth"

// GET - Fetch all admin users
export const GET = withAuth(async (request: NextRequest, user) => {
  try {
    const db = await connectDB()
    const { searchParams } = new URL(request.url)
    
    // Filter by companyId - admins see only their company's users
    let query = {}
    if (user.role !== "super-admin") {
      // Regular admins can only see users from their company
      const companyId = user.companyId || user.userId
      query = { companyId: companyId }
    }
    
    const adminUsers = await db.collection(Collections.ADMIN_USERS).find(query).toArray()
    
    // Fetch associated roles for each user
    const usersWithRoles = await Promise.all(
      adminUsers.map(async (u) => {
        let roleName = null
        if (u.roleId) {
          try {
            const role = await db.collection(Collections.ROLES).findOne({ _id: new ObjectId(u.roleId) })
            roleName = role?.name || null
          } catch (err) {
            console.error("Error fetching role:", err)
          }
        }
        
        const { password, ...safeUser } = u
        return { 
          ...safeUser, 
          id: u._id.toString(), 
          _id: u._id.toString(),
          roleName 
        }
      })
    )
    
    return NextResponse.json({ success: true, data: usersWithRoles, users: usersWithRoles })
  } catch (error) {
    console.error("[API-USERS] GET error:", error)
    return NextResponse.json({ success: false, error: "Failed to fetch users" }, { status: 500 })
  }
})

// POST - Create new admin user
export const POST = withAuth(async (request: NextRequest, user) => {
  try {
    const db = await connectDB()
    const data = await request.json()
    
    // Validate required fields
    if (!data.email || !data.password || !data.name) {
      return NextResponse.json(
        { success: false, error: "Email, password, and name are required" }, 
        { status: 400 }
      )
    }
    
    // Check if email already exists
    const existingUser = await db.collection(Collections.ADMIN_USERS).findOne({ email: data.email })
    
    // Also check regular users collection to prevent email conflicts
    const existingRegularUser = await db.collection(Collections.USERS).findOne({ email: data.email })
    if (existingRegularUser) {
      return NextResponse.json(
        { success: false, error: "Email already exists in the system" }, 
        { status: 409 }
      )
    }
    if (existingUser) {
      return NextResponse.json(
        { success: false, error: "Email already exists" }, 
        { status: 409 }
      )
    }
    
    // Hash password
    const hashedPassword = await bcrypt.hash(data.password, 10)
    
    // Fetch role permissions if roleId is provided
    let permissions = []
    if (data.roleId) {
      const role = await db.collection(Collections.ROLES).findOne({ _id: new ObjectId(data.roleId) })
      if (role) {
        permissions = role.permissions || []
      }
    }
    
    // Automatically set companyId from the creating user
    // For super-admin, use their userId; for regular admin, use their companyId or userId
    let companyId = data.companyId
    if (!companyId) {
      companyId = user.companyId || user.userId
    }
    
    const newAdminUser = {
      email: data.email,
      password: hashedPassword,
      name: data.name,
      companyId: companyId,
      role: data.role || "admin",  // "admin" or "super-admin"
      roleId: data.roleId || null,
      permissions: permissions,
      phone: data.phone || null,
      avatar: data.avatar || null,
      isActive: data.isActive !== undefined ? data.isActive : true,
      createdAt: new Date(),
      updatedAt: new Date(),
      lastLogin: null,
    }
    
    const result = await db.collection(Collections.ADMIN_USERS).insertOne(newAdminUser)
    
    // Remove password from response
    const { password: _, ...safeUser } = newAdminUser
    
    return NextResponse.json({ 
      success: true, 
      data: { ...safeUser, _id: result.insertedId, id: result.insertedId.toString() },
      user: { ...safeUser, _id: result.insertedId, id: result.insertedId.toString() }
    })
  } catch (error) {
    console.error("[API-USERS] POST error:", error)
    return NextResponse.json({ success: false, error: "Failed to create user" }, { status: 500 })
  }
})
